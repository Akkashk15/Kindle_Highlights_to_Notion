"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const slugify_1 = require("slugify");
const SEPERATOR = '';
const types = {
    page: 'a',
    text: 'p',
    header: 'h1',
    sub_header: 'h3',
    sub_sub_header: 'h5',
    divider: 'hr',
    break: 'br',
    numbered_list: 'ol',
    bulleted_list: 'ul',
    image: 'img'
};
function formatToHtml(ObjectToParse, options, index) {
    let { type, properties, format } = ObjectToParse;
    const color = format && format.block_color;
    const customColor = color &&
        options.colors &&
        (options.colors[color.split('_')[0]] || color);
    const content = properties &&
        properties.title &&
        properties.title[0][0].replace(/\[.*\]:.{1,}/, '');
    const source = properties &&
        properties.source;
    const tags = (content && content[0] ? content[0][0] : '').match(/\[.{1,}\]: .{1,}/);
    const attrib = tags && tags[0].replace(/(\[|\])/g, '').split(':');
    if (attrib && attrib.length == 2) {
        return {
            [attrib[0]]: attrib[1].trim()
        };
    }
    const property = customColor && color.includes('background')
        ? `style="background-color:${customColor.split('_')[0]}"`
        : `style="color:${customColor}"`;
    const style = color ? ` ${property}` : '';
    if (!content && type !== 'divider' && !source) {
        type = 'break';
    }
    switch (types[type]) {
        case types.page: {
            if (index === 0) {
                return `<h1 ${style}>${content}</h1>`;
            }
            return null;
        }
        case types.divider: {
            return `<${types.divider}${style}/>`;
        }
        case types.break: {
            return `<${types.break} />`;
        }
        case types.numbered_list:
        case types.bulleted_list: {
            return `<li${style}>${content}</li>`;
        }
        case types.image: {
            return `<${types.image}${style} src="${source}" />`;
        }
        default: {
            if (types[type])
                return `<${types[type]}${style}>${content}</${types[type]}>`;
            return null;
        }
    }
}
function formatList(ObjectList, options, htmlFormatter) {
    const items = [];
    const attributes = {};
    for (let index = 0; index < ObjectList.length; index += 1) {
        const element = ObjectList[index];
        let html;
        if (htmlFormatter) {
            html = htmlFormatter(element, options, index, ObjectList);
        }
        else {
            html = formatToHtml(element, options, index);
        }
        if (html && typeof html === 'object') {
            const keys = Object.keys(html);
            keys.forEach(key => {
                attributes[key] = html[key];
            });
        }
        else if (element &&
            element.type.includes('list') &&
            !element.type.includes('column')) {
            if (ObjectList[index - 1] &&
                !ObjectList[index - 1].type.includes('list')) {
                html = `<${types[element.type]}>${SEPERATOR}${html}`;
            }
            if (index + 1 >= ObjectList.length ||
                (ObjectList[index + 1] && !ObjectList[index + 1].type.includes('list'))) {
                html = `${html}${SEPERATOR}</${types[element.type]}>`;
            }
        }
        if (typeof html === 'string') {
            items.push(html);
        }
    }
    const { format, created_time, last_edited_time, properties } = ObjectList[0];
    const created_datetime = new Date(created_time).toDateString();
    const last_edited_datetime = new Date(last_edited_time).toDateString();
    const title = (properties && properties.title && properties.title[0][0]) || '';
    const cover = format && format.page_cover
        ? format.page_cover.includes('http')
            ? format.page_cover
            : `https://www.notion.so${format.page_cover}`
        : null;
    return {
        items,
        attributes: Object.assign({}, attributes, { title,
            created_datetime,
            last_edited_datetime, slug: slugify_1.default(title, { lower: true }), cover, teaser: items
                .map(i => i
                .replace(/\[.{1,}\]: .{1,}/g, '')
                .replace(/\<a.*\>*\<\/a\>/g, '')
                .replace(/<[^>]*>/g, ''))
                .filter(i => i)
                .join(' ')
                .trim()
                .substring(0, 200), icon: format ? format.page_icon : null })
    };
}
function toHTMLPage(ObjectList, options, htmlFormatter) {
    const { items, attributes } = formatList(ObjectList, options, htmlFormatter);
    const elementsString = items.join('');
    return {
        HTML: elementsString ? `<div>${elementsString}</div>` : '',
        Attributes: Object.assign({}, attributes, { id: ObjectList[0].id })
    };
}
function handleNotionError(err) {
    if (err.message.includes('block')) {
        console.error('Authentication Error: Please check your token!');
    }
    else {
        console.error(err);
    }
}
exports.handleNotionError = handleNotionError;
function isNotionID(id) {
    const idRegex = new RegExp(/[a-z,0-9]{8}-[a-z,0-9]{4}-[a-z,0-9]{4}-[a-z,0-9]{4}-[a-z,0-9]{12}/g);
    return idRegex.test(id);
}
exports.isNotionID = isNotionID;
exports.default = toHTMLPage;
